<!DOCTYPE html>
<meta charset="UTF-8">
<title></title>
<style>
* {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
}
</style>
<div id=app>
</div>
<script async src="https://unpkg.com/es-module-shims@1.6.3/dist/es-module-shims.js"></script>
<script type="importmap">
{
    "imports": {
        "three": "https://unpkg.com/three@0.155.0/build/three.module.js",
        "three/addons/": "https://unpkg.com/three@0.155.0/examples/jsm/"
    }
}
</script>
<script src="https://unpkg.com/@babel/standalone@7.22.9/babel.min.js"></script>
<script type="text/babel" data-plugins="syntax-do-expressions,proposal-do-expressions" data-type="module">
import * as THREE from 'three';
import { ARButton } from 'three/addons/webxr/ARButton.js';
import { TrackballControls } from 'three/addons/controls/TrackballControls.js';

const renderer = do {
    const alpha = true;
    const antialias = true;
    new THREE.WebGLRenderer({ alpha, antialias });
};
renderer.setPixelRatio(window.devicePixelRatio);
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.autoClear = false;
renderer.xr.enabled = true;
renderer.setAnimationLoop(render);
document.body.appendChild(renderer.domElement);

{
    const button = ARButton.createButton(renderer);
    document.body.appendChild(button);
};

const scene = do {
    new THREE.Scene();
};
scene.background = new THREE.Color(0x505050);

const camera = do {
    const fov = 77;
    const aspect = do {
        const { x: width, y: height } = renderer.getSize(new THREE.Vector2());
        width / height;
    };
    const near = 0.1;
    const far = 100.0;
    new THREE.PerspectiveCamera(fov, aspect, near, far);
};
camera.position.set(0.0, 0.0, 0.0);
camera.up.set(0.0, 1.0, 0.0);
camera.lookAt(1.0, 0.0, 0.0);

const textureLoader = do {
    new THREE.TextureLoader();
};

let trackball = makeTrackball();
function makeTrackball() {
    const trackball = do {
        const camera_ = do {
            camera.clone();
        };
        camera_.position.set(1.0, 0.0, 0.0);
        camera_.up.set(0.0, -1.0, 0.0);
        const domElement = renderer.domElement;
        new TrackballControls(camera_, domElement);
    };
    trackball.target.set(0.0, 0.0, 0.0);
    return trackball;
};

let recenter = makeRecenter();
function makeRecenter() {
    const recenter = do {
        new RecenterCameraControls(renderer);
    };
    return recenter;
};

// const recorder = new RecorderControls();

renderer.xr.addEventListener('sessionstart', onsessionstart);
renderer.xr.addEventListener('sessionend', onsessionend);

const mesh = do {
    const geometry = do {
        const radius = 1.0;
        const widthSegments = 60;
        const heightSegments = 40;
        new THREE.SphereGeometry(radius, widthSegments, heightSegments);
    };
    geometry.scale(-1.0, 1.0, 1.0); // make all faces point inwards
    geometry.rotateY(Math.PI);
//     geometry.rotateX(Math.PI);
    const material = do {
        const transparent = true;
        const side = THREE.DoubleSide;
        const map = do {
            const position = [563.2271446178601, 3706.84551063691, -5153.367883611318]
            const up = [563.2271446178601, 3706.84551063691, -5153.367883611318]
            const direction = [3.3002321090438045, 0.29997060238702034, 1.1959763137756454]
            const params = new URLSearchParams();
            params.set('position', `${position}`);
            params.set('up', `${up}`);
            params.set('direction', `${direction}`);
            const url = `api/v1/view/?${params}`;
            textureLoader.load(url);
        };
        new THREE.MeshBasicMaterial({ transparent, side, map });
    };
    new THREE.Mesh(geometry, material);
};
scene.add(mesh);

// setTimeout(oninterval, 5000);
// async function oninterval() {
//     console.log({ x: scene.position.x, y: scene.position.y, z: scene.position.z });
//     console.log({ x: camera.position.x, y: camera.position.y, z: camera.position.z });
//     
//     const position = [
//         563.2271446178601 +  100 * (scene.position.x - camera.position.x),
//         3706.84551063691 +   100 * (scene.position.y - camera.position.y),
//         -5153.367883611318 + 100 * (scene.position.z - camera.position.z),
//     ]
//     const up = [
//         563.2271446178601,
//         3706.84551063691,
//         -5153.367883611318,
//     ]
//     const direction = [
//         3.3002321090438045,
//         0.29997060238702034,
//         1.1959763137756454,
//     ]
//     const params = new URLSearchParams();
//     params.set('position', `${position}`);
//     params.set('up', `${up}`);
//     params.set('direction', `${direction}`);
//     const url = `api/v1/view/?${params}`;
//     const texture = await new Promise((resolve, reject) => {
//         textureLoader.load(url, resolve, undefined, reject);
//     });
//     mesh.material.map = texture;
//     mesh.material.needsUpdate = true;
//     
//     setTimeout(oninterval, 5000);
// }

function onsessionstart() {
    trackball.dispose();
    trackball = null;
}

function onsessionend() {
    trackball = makeTrackball();
}

function render() {
    if (trackball !== null) {
        trackball.update();
        {
            const src = trackball.object.position;
            camera.lookAt(src.x, -src.y, src.z);
        }
//        {
//            const src = trackball.object.up.clone();
//            // src.multiplyScalar(-1.0);
//            const dst = camera.up;
//            dst.copy(src);
//        }
    }
    
//     recorder.update(camera);
    recenter.update(scene, camera);
    renderer.render(scene, camera);
}

//=== Replay camera coordinates

function ReplayerControls() {
    const history = [];
    
    
    return Object.assign(this, {
        update,
    })
    
    function update(camera) {
        
    }


    //--- Utilities
    
    function get() { //-> [ {now, position, up, direction}, ... ]
        
    }
    
    function now() { //-> milliseconds
        return Date.now();
    }
}

//=== Record camera coordinates

function RecorderControls() {
    const history = [];
    const start = now();
    let interval = setTimeout(oninterval, 5000);
    
    return Object.assign(this, {
        update,
        dispose,
    });
    
    function update(camera) {
        history.push({
            now: now() - start,
            position: position(camera),
            up: up(camera),
            direction: direction(camera),
        });
    }
    
    function dispose() {
        clearTimeout(interval);
    }

    
    //--- Event Handlers
    
    async function oninterval() {
        const body = {
            history: [...history],
        };
        history.splice(0, history.length);
        
        const response = await fetch('api/v1/history/', {
            method: 'POST',
            mode: 'cors',
            body: JSON.stringify(body),
        });
        await response.text();
        
        interval = setTimeout(oninterval, 5000);
    }
    
    
    //--- Utilities
    
    function position(object) {
        return {
            x: camera.position.x,
            y: camera.position.y,
            z: camera.position.z,
        };
    }
    
    function up(object) {
        return {
            x: camera.up.x,
            y: camera.up.y,
            z: camera.up.z,
        };
    }
    
    function direction(object) {
        const direction = new THREE.Vector3();
        object.getWorldDirection(direction);
        return {
            x: direction.x,
            y: direction.y,
            z: direction.z,
        };
    }
    
    function now() { //-> milliseconds
        return Date.now();
    }
}


//=== Let the user re-center the scene at the camera

function RecenterCameraControls(renderer) {
    let timeout = null;
    let needsUpdate = false;
    let controller = null;
    renderer.domElement.addEventListener('pointerdown', onstart, true);
    renderer.domElement.addEventListener('pointerup', onend, true);
    renderer.xr.addEventListener('sessionstart', onsessionstart, true);
    renderer.xr.addEventListener('sessionend', onsessionend, true);
    
    return Object.assign(this, {
        update,
        dispose,
    });
    
    
    //--- Instance Methods
    
    function update(scene, camera) {
        if (needsUpdate) {
            onupdate(scene, camera);
            needsUpdate = false;
        }
    }
    
    function dispose() {
        renderer.domElement.removeEventListener('pointerdown', onstart, true);
        renderer.domElement.removeEventListener('pointerup', onend, true);
    }
    
    function onlongtouch() {
        needsUpdate = true;
    }
    
    function onshorttouch() {
        //
    }
    
    
    //--- Event Listeners
    
    function onsessionstart() {
        controller = renderer.xr.getController(0);
        controller.addEventListener('selectstart', onstart, true);
        controller.addEventListener('selectend', onend, true);
        controller.addEventListener('select', onlongtouch, true);
    }
    
    function onsessionend() {
        controller.removeEventListener('selectstart', onstart, true);
        controller.removeEventListener('selectend', onend, true);
        controller.removeEventListener('select', onlongtouch, true);
        controller = null;
    }
    
    function onupdate(scene, camera) {
        console.group('RecenterCameraControls.onupdate');
        console.log('scene.position', JSON.parse(JSON.stringify(scene.position)));
        console.log('camera.position', JSON.parse(JSON.stringify(camera.position)));
        scene.position.copy(camera.position);
        console.groupEnd();
    }
    
    function onstart() {
        timeout = setTimeout(ontimeout, 1000);
    }
    
    function onend() {
        clearTimeout(timeout);
        timeout = null;
    }
    
    function ontimeout() {
        onlongtouch();
    }
}

</script>
